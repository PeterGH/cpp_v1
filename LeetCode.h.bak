#ifndef _LEETCODE_H_
#define _LEETCODE_H_

#include <algorithm>
#include <functional>
#include <limits.h>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <unordered_map>
#include <vector>

using namespace std;

namespace Test {
namespace LeetCode {

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

struct TreeLinkNode {
    TreeLinkNode *left;
    TreeLinkNode *right;
    TreeLinkNode *next;
};

// 117. Populating Next Right Pointers in Each Node II
// Follow up for problem "Populating Next Right Pointers in Each Node". What if
// the given tree could be any binarytree ? Would your previous solution still
// work? Note: You may only use constant extra space. For example, Given the
// following binary tree,
//     1
//    / \
//   2    3
//  / \    \
// 4   5    7
// After calling your function, the tree should look like :
//     1->NULL
//    / \
//   2 -> 3->NULL
//  / \    \
// 4-> 5 -> 7->NULL
static void connect2(TreeLinkNode *root) {
    TreeLinkNode *leftMost = root;
    while (leftMost != nullptr) {
        TreeLinkNode *node = leftMost;
        leftMost = nullptr;
        TreeLinkNode *left = nullptr;
        while (node != nullptr) {
            if (node->left != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->left;
                }
                if (left != nullptr) {
                    left->next = node->left;
                }
                left = node->left;
            }
            if (node->right != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->right;
                }
                if (left != nullptr) {
                    left->next = node->right;
                }
                left = node->right;
            }
            node = node->next;
        }
    }
}

// 133. Clone Graph
// Clone an undirected graph. Each node in the graph contains a label and a list
// of its neighbors. OJ's undirected graph serialization: Nodes are labeled
// uniquely. We use # as a separator for each node, and , as a separator for
// node label and each neighbor of the node. As an example, consider the
// serialized graph { 0,1,2#1,2#2,2 }. The graph has a total of three nodes, and
// therefore contains three parts as separated by #. First node is labeled as 0.
// Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect
// node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2
// (itself), thus forming a self-cycle. Visually, the graph looks like the
// following :
//    1
//   /  \
//  /    \
// 0 -- - 2
//       / \
//       \_/
struct UndirectedGraphNode {
    int label;
    vector<UndirectedGraphNode *> neighbors;
    UndirectedGraphNode(int x) : label(x){};
};
static UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    map<int, UndirectedGraphNode *> cloned;
    function<UndirectedGraphNode *(UndirectedGraphNode *)> clone =
        [&](UndirectedGraphNode *n) -> UndirectedGraphNode * {
        if (n == nullptr)
            return nullptr;
        if (cloned.find(n->label) != cloned.end())
            return cloned[n->label];
        UndirectedGraphNode *copy = new UndirectedGraphNode(n->label);
        cloned[n->label] = copy;
        for (size_t i = 0; i < n->neighbors.size(); i++) {
            int label = n->neighbors[i]->label;
            if (cloned.find(label) == cloned.end()) {
                cloned[label] = clone(n->neighbors[i]);
            }
            copy->neighbors.push_back(cloned[label]);
        }
        return copy;
    };
    return clone(node);
}

struct RandomListNode {
    int label;
    RandomListNode *next, *random;
    RandomListNode(int x) : label(x), next(nullptr), random(nullptr) {}
};
// 138. Copy List with Random Pointer
// A linked list is given such that each node contains an additional random
// pointer which could point to any node in the list or null. Return a deep copy
// of the list.
static RandomListNode *copyRandomList(RandomListNode *head) {
    map<RandomListNode *, RandomListNode *> copied;
    function<RandomListNode *(RandomListNode *)> copy =
        [&](RandomListNode *node) -> RandomListNode * {
        if (node == nullptr)
            return nullptr;
        RandomListNode *c = new RandomListNode(node->label);
        copied[node] = c;
        if (copied.find(node->next) == copied.end()) {
            copied[node->next] = copy(node->next);
        }
        c->next = copied[node->next];
        if (copied.find(node->random) == copied.end()) {
            copied[node->random] = copy(node->random);
        }
        c->random = copied[node->random];
        return c;
    };
    return copy(head);
}
} // namespace LeetCode
} // namespace Test

#endif
