#ifndef _LEETCODE_H_
#define _LEETCODE_H_

#include <algorithm>
#include <functional>
#include <limits.h>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <unordered_map>
#include <vector>

using namespace std;

namespace Test {
namespace LeetCode {

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 114. Flatten Binary Tree to Linked List
// Given a binary tree, flatten it to a linked list in-place. For example, Given
//     1
//    / \
//   2   5
//  / \   \
// 3   4   6
// The flattened tree should look like:
// 1
//  \
//   2
//    \
//     3
//      \
//       4
//        \
//         5
//          \
//           6
static void flatten(TreeNode *root) {
    function<TreeNode *(TreeNode *)> solve = [&](TreeNode *node) -> TreeNode * {
        if (node == nullptr)
            return nullptr;
        if (node->left == nullptr && node->right == nullptr) {
            return node;
        }
        TreeNode *leftTail = solve(node->left);
        TreeNode *rightTail = solve(node->right);
        if (leftTail != nullptr) {
            leftTail->right = node->right;
            node->right = node->left;
            node->left = nullptr;
        }
        return rightTail == nullptr ? leftTail : rightTail;
    };
    solve(root);
}

// 173. Binary Search Tree Iterator
// Implement an iterator over a binary search tree (BST). Your iterator will be
// initialized with the root node of a BST. Calling next() will return the next
// smallest number in the BST. Note: next() and hasNext() should run in average
// O(1) time and uses O(h) memory, where h is the height of the tree.
class BSTIterator {
  private:
    stack<TreeNode *> _stack;
    TreeNode *_node;

  public:
    BSTIterator(TreeNode *root) { _node = root; }

    /** @return whether we have a next smallest number */
    bool hasNext() { return !_stack.empty() || _node != nullptr; }

    /** @return the next smallest number */
    int next() {
        int val;
        while (hasNext()) {
            if (_node != nullptr) {
                _stack.push(_node);
                _node = _node->left;
            } else {
                _node = _stack.top();
                _stack.pop();
                val = _node->val;
                _node = _node->right;
                break;
            }
        }
        return val;
    }
};

struct TreeLinkNode {
    TreeLinkNode *left;
    TreeLinkNode *right;
    TreeLinkNode *next;
};

// 116. Populating Next Right Pointers in Each Node
// Given a binary tree Populate each next pointer to point to its next right
// node. If there is no next right node, the next pointer should be set to NULL.
// Initially, all next pointers are set to NULL. Note: You may only use constant
// extra space. You may assume that it is a perfect binary tree (ie, all leaves
// are at the same level, and every parent has two children). For example, Given
// the following perfect binary tree,
//      1
//    /   \
//   2     3
//  / \   / \
// 4   5 6   7
// After calling your function, the tree should look like :
//      1->NULL
//    /   \
//   2 ->  3->NULL
//  / \   / \
// 4-> 5->6->7->NULL
static void connect(TreeLinkNode *root) {
    TreeLinkNode *leftMost = root;
    while (leftMost != nullptr && leftMost->left != nullptr) {
        TreeLinkNode *node = leftMost;
        leftMost = leftMost->left;
        TreeLinkNode *left = nullptr;
        while (node != nullptr) {
            if (left != nullptr) {
                left->next = node->left;
            }
            node->left->next = node->right;
            left = node->right;
            node = node->next;
        }
    }
}

// 117. Populating Next Right Pointers in Each Node II
// Follow up for problem "Populating Next Right Pointers in Each Node". What if
// the given tree could be any binarytree ? Would your previous solution still
// work? Note: You may only use constant extra space. For example, Given the
// following binary tree,
//     1
//    / \
//   2    3
//  / \    \
// 4   5    7
// After calling your function, the tree should look like :
//     1->NULL
//    / \
//   2 -> 3->NULL
//  / \    \
// 4-> 5 -> 7->NULL
static void connect2(TreeLinkNode *root) {
    TreeLinkNode *leftMost = root;
    while (leftMost != nullptr) {
        TreeLinkNode *node = leftMost;
        leftMost = nullptr;
        TreeLinkNode *left = nullptr;
        while (node != nullptr) {
            if (node->left != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->left;
                }
                if (left != nullptr) {
                    left->next = node->left;
                }
                left = node->left;
            }
            if (node->right != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->right;
                }
                if (left != nullptr) {
                    left->next = node->right;
                }
                left = node->right;
            }
            node = node->next;
        }
    }
}

// 133. Clone Graph
// Clone an undirected graph. Each node in the graph contains a label and a list
// of its neighbors. OJ's undirected graph serialization: Nodes are labeled
// uniquely. We use # as a separator for each node, and , as a separator for
// node label and each neighbor of the node. As an example, consider the
// serialized graph { 0,1,2#1,2#2,2 }. The graph has a total of three nodes, and
// therefore contains three parts as separated by #. First node is labeled as 0.
// Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect
// node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2
// (itself), thus forming a self-cycle. Visually, the graph looks like the
// following :
//    1
//   /  \
//  /    \
// 0 -- - 2
//       / \
//       \_/
struct UndirectedGraphNode {
    int label;
    vector<UndirectedGraphNode *> neighbors;
    UndirectedGraphNode(int x) : label(x){};
};
static UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    map<int, UndirectedGraphNode *> cloned;
    function<UndirectedGraphNode *(UndirectedGraphNode *)> clone =
        [&](UndirectedGraphNode *n) -> UndirectedGraphNode * {
        if (n == nullptr)
            return nullptr;
        if (cloned.find(n->label) != cloned.end())
            return cloned[n->label];
        UndirectedGraphNode *copy = new UndirectedGraphNode(n->label);
        cloned[n->label] = copy;
        for (size_t i = 0; i < n->neighbors.size(); i++) {
            int label = n->neighbors[i]->label;
            if (cloned.find(label) == cloned.end()) {
                cloned[label] = clone(n->neighbors[i]);
            }
            copy->neighbors.push_back(cloned[label]);
        }
        return copy;
    };
    return clone(node);
}

struct RandomListNode {
    int label;
    RandomListNode *next, *random;
    RandomListNode(int x) : label(x), next(nullptr), random(nullptr) {}
};
// 138. Copy List with Random Pointer
// A linked list is given such that each node contains an additional random
// pointer which could point to any node in the list or null. Return a deep copy
// of the list.
static RandomListNode *copyRandomList(RandomListNode *head) {
    map<RandomListNode *, RandomListNode *> copied;
    function<RandomListNode *(RandomListNode *)> copy =
        [&](RandomListNode *node) -> RandomListNode * {
        if (node == nullptr)
            return nullptr;
        RandomListNode *c = new RandomListNode(node->label);
        copied[node] = c;
        if (copied.find(node->next) == copied.end()) {
            copied[node->next] = copy(node->next);
        }
        c->next = copied[node->next];
        if (copied.find(node->random) == copied.end()) {
            copied[node->random] = copy(node->random);
        }
        c->random = copied[node->random];
        return c;
    };
    return copy(head);
}
} // namespace LeetCode
} // namespace Test

#endif
