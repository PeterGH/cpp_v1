#ifndef _LEETCODE_H_
#define _LEETCODE_H_

#include <algorithm>
#include <functional>
#include <limits.h>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <unordered_map>
#include <vector>

using namespace std;

namespace Test {
namespace LeetCode {

// 118. Pascal's Triangle
// Given numRows, generate the first numRows of Pascal's triangle. For example,
// given numRows = 5, Return
// [
//      [1],
//     [1, 1],
//    [1, 2, 1],
//   [1, 3, 3, 1],
//  [1, 4, 6, 4, 1]
// ]
static vector<vector<int>> generate(int numRows) {
    vector<vector<int>> result;
    if (numRows <= 0)
        return result;
    vector<int> row;
    for (int i = 0; i < numRows; i++) {
        row.push_back(1);
        for (int j = row.size() - 2; j > 0; j--) {
            row[j] += row[j - 1];
        }
        result.push_back(row);
        row = vector<int>(row);
    }
    return result;
}

// 119. Pascal's Triangle II
// Given an index k, return the kth row of the Pascal's triangle. For example,
// given k = 3, Return [1, 3, 3, 1]. Note: Could you optimize your algorithm
// to use only O(k) extra space ?
static vector<int> getRow(int rowIndex) {
    vector<int> row;
    for (int k = 0; k <= rowIndex; k++) {
        row.push_back(1);
        for (int i = row.size() - 2; i > 0; i--) {
            row[i] += row[i - 1];
        }
    }
    return row;
}

// 120. Triangle
// Given a triangle, find the minimum path sum from top to bottom. Each step you
// may move to adjacent numbers on the row below. For example, given the
// following triangle
// [
//     [2],
//    [3, 4],
//   [6, 5, 7],
//  [4, 1, 8, 3]
// ]
// The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
// Note: Bonus point if you are able to do this using only O(n) extra space,
// where n is the total number of rows in the triangle.
static int minimumTotal(vector<vector<int>> &triangle) {
    vector<int> row(triangle[0]);
    for (size_t i = 1; i < triangle.size(); i++) {
        size_t n = triangle[i].size();
        row.push_back(row[n - 2] + triangle[i][n - 1]);
        for (int j = n - 2; j > 0; j--) {
            row[j] = triangle[i][j] + min(row[j - 1], row[j]);
        }
        row[0] += triangle[i][0];
    }
    int min = row[0];
    for (size_t i = 1; i < row.size(); i++) {
        if (row[i] < min)
            min = row[i];
    }
    return min;
}

// 155. Min Stack
// Design a stack that supports push, pop, top, and retrieving the minimum
// element in constant time.
// push(x) --  Push element x onto stack.
// pop()   --  Removes the element on top of the stack.
// top()   --  Get the top element.
// getMin() -- Retrieve the minimum element in the stack.
// Example:
// MinStack minStack = new MinStack();
// minStack.push(-2);
// minStack.push(0);
// minStack.push(-3);
// minStack.getMin();   --> Returns -3.
// minStack.pop();
// minStack.top();      --> Returns 0.
// minStack.getMin();   --> Returns -2.
class MinStack {
  private:
    stack<int> _items;
    stack<int> _mins;

  public:
    // initialize your data structure here.
    MinStack() {}

    void push(int x) {
        _items.push(x);
        if (!_mins.empty())
            x = min(_mins.top(), x);
        _mins.push(x);
    }

    void pop() {
        _items.pop();
        _mins.pop();
    }

    int top() { return _items.top(); }

    int getMin() { return _mins.top(); }
};

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

static void Print(ListNode *node) {
    if (node == nullptr)
        return;
    while (node != nullptr) {
        cout << node->val << "->";
        node = node->next;
    }
    cout << "null" << endl;
}

static void DeleteList(ListNode *node) {
    if (node == nullptr)
        return;
    ListNode *p = node;
    while (p != nullptr) {
        node = p->next;
        delete p;
        p = node;
    }
}

static ListNode *ToList(vector<int> &numbers) {
    ListNode *list = nullptr;
    if (numbers.size() == 0)
        return list;
    list = new ListNode(numbers[0]);
    ListNode *n = list;
    for (size_t i = 1; i < numbers.size(); i++) {
        n->next = new ListNode(numbers[i]);
        n = n->next;
    }
    return list;
}

static ListNode *MergeSortedLists(ListNode *l1, ListNode *l2) {
    if (l1 == nullptr)
        return l2;
    if (l2 == nullptr)
        return l1;

    ListNode *head = l1;
    if (l1->val > l2->val) {
        head = l2;
        l2 = l2->next;
    } else {
        l1 = l1->next;
    }

    ListNode *p = head;

    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val <= l2->val) {
            if (p->next != l1)
                p->next = l1;
            p = l1;
            l1 = p->next;
        } else {
            if (p->next != l2)
                p->next = l2;
            p = l2;
            l2 = p->next;
        }
    }

    ListNode *q = l1 == nullptr ? l2 : l1;
    if (q != nullptr && p->next != q)
        p->next = q;

    return head;
}

// Merge k sorted linked lists and return it as one sorted list.
static ListNode *MergeKLists(vector<ListNode *> &lists) {
    if (lists.size() == 0)
        return nullptr;
    ListNode *list = nullptr;
    ListNode *tail = list;
    while (true) {
        ListNode *mp = nullptr;
        int mi = 0;
        for (int i = 0; i < (int)lists.size(); i++) {
            if (lists[i] != nullptr) {
                if (mp == nullptr || lists[i]->val < mp->val) {
                    mp = lists[i];
                    mi = i;
                }
            }
        }
        if (mp == nullptr)
            break;
        if (list == nullptr)
            list = mp;
        else
            tail->next = mp;
        tail = mp;
        lists[mi] = mp->next;
    }
    return list;
}
static bool Greater(ListNode *first, ListNode *second) {
    if (first == nullptr && second == nullptr)
        return false;
    if (first == nullptr && second != nullptr)
        return true;
    if (first != nullptr && second == nullptr)
        return false;
    if (first->val > second->val)
        return true;
    else
        return false;
}
static ListNode *MergeKLists2(vector<ListNode *> &lists) {
    if (lists.size() == 0)
        return nullptr;
    ListNode *list = nullptr;
    ListNode *tail = list;
    make_heap(lists.begin(), lists.end(), Greater);
    while (lists.front() != nullptr) {
        pop_heap(lists.begin(), lists.end(), Greater);
        if (list == nullptr)
            list = lists.back();
        else
            tail->next = lists.back();
        tail = lists.back();
        lists.back() = lists.back()->next;
        push_heap(lists.begin(), lists.end(), Greater);
    }
    return list;
}
static ListNode *MergeKLists3(vector<ListNode *> &lists) {
    if (lists.size() == 0)
        return nullptr;
    ListNode *list = nullptr;
    ListNode *tail = list;
    make_heap(lists.begin(), lists.end(), Greater);
    while (lists.size() > 0) {
        pop_heap(lists.begin(), lists.end(), Greater);
        if (lists.back() == nullptr)
            break;
        if (list == nullptr)
            list = lists.back();
        else
            tail->next = lists.back();
        tail = lists.back();
        lists.back() = lists.back()->next;
        if (lists.back() == nullptr)
            lists.pop_back();
        else
            push_heap(lists.begin(), lists.end(), Greater);
    }
    return list;
}

// 61. Rotate List
// Given a list, rotate the list to the right by k places, where k is
// non-negative. For example : Given 1->2->3->4->5->NULL and k = 2, return
// 4->5->1->2->3->NULL.
static ListNode *rotateRight(ListNode *head, int k) {
    if (head == nullptr)
        return head;
    ListNode *tail = head;
    int i = 1;
    while (tail->next != nullptr) {
        i++;
        tail = tail->next;
    }
    // tail is the last element and is the i-th element (1-based)
    k %= i;
    if (k == 0)
        return head;
    int j = i - k;
    // TODO: compute p in the while loop above.
    // Be careful when k is larger than the list length.
    ListNode *p = head;
    while (j > 1) {
        p = p->next;
        j--;
    }
    tail->next = head;
    head = p->next;
    p->next = nullptr;
    return head;
}
static ListNode *rotateRight2(ListNode *head, int k) {
    if (head == nullptr || k <= 0)
        return head;
    ListNode *p = head;
    ListNode *q = head;
    int i = 0;
    while (i < k && q->next != nullptr) {
        q = q->next;
        i++;
    }
    // q is the i-th element (0-based)
    if (q->next == nullptr) {
        int l = i + 1; // total length
        k = k % l;
        if (k == 0)
            return head;
        i = 0;
        q = head;
        while (i < k && q->next != nullptr) {
            q = q->next;
            i++;
        }
    }
    // q is the k-th element (0-based)
    while (q->next != nullptr) {
        q = q->next;
        p = p->next;
    }
    q->next = head;
    head = p->next;
    p->next = nullptr;
    return head;
}

// 92. Reverse Linked List II
// Reverse a linked list from position m to n. Do it in-place and in one-pass.
// For example : Given 1->2->3->4->5->NULL, m = 2 and n = 4,
// return 1->4->3->2->5->NULL.
// Note : Given m, n satisfy the following condition :
// 1 <= m <= n <= length of list.
static ListNode *reverseBetween(ListNode *head, int m, int n) {
    if (head == nullptr)
        return nullptr;
    ListNode *pm_prev = nullptr;
    ListNode *pm = nullptr;
    int i;
    if (m == 1) {
        pm = head;
    } else {
        pm_prev = head;
        i = 1;
        while (i < m - 1 && pm_prev->next != nullptr) {
            pm_prev = pm_prev->next;
            i++;
        }
        if (i < m - 1)
            return head;
        pm = pm_prev->next;
    }
    ListNode *pn = pm;
    i = m;
    while (i < n && pn->next != nullptr) {
        pn = pn->next;
        i++;
    }
    ListNode *pn_next = pn->next;
    ListNode *prev = pn_next;
    ListNode *curr = pm;
    ListNode *next = pm->next;
    while (curr != pn) {
        curr->next = prev;
        prev = curr;
        curr = next;
        next = curr->next;
    }
    curr->next = prev;
    if (pm_prev == nullptr) {
        head = pn;
    } else {
        pm_prev->next = pn;
    }
    return head;
}
static ListNode *reverseBetween2(ListNode *head, int m, int n) {
    if (head == nullptr || m <= 0 || n <= 0 || m >= n)
        return head;

    ListNode *ph = nullptr;
    ListNode *pm = head;
    int i = 1;
    while (i < m && pm->next != nullptr) {
        ph = pm;
        pm = pm->next;
        i++;
    }

    if (i < m)
        return head;

    ListNode *r = ph;
    ListNode *s = pm;
    ListNode *t = pm->next;

    while (i <= n && t != nullptr) {
        s->next = r;
        r = s;
        s = t;
        t = t->next;
        i++;
    }

    if (i <= n && t == nullptr) {
        s->next = r;
        r = s;
        s = t;
    }

    pm->next = s;
    if (ph != nullptr)
        ph->next = r;
    else
        head = r;

    return head;
}

// Given a linked list, swap every two adjacent nodes and return its head.
// For example, Given 1->2->3->4, you should return the list as 2->1->4->3.
// Your algorithm should use only constant space. You may not modify the
// values in the list, only nodes itself can be changed.
static ListNode *SwapPairs(ListNode *head) {
    if (head == nullptr || head->next == nullptr)
        return head;

    ListNode *f = head;
    ListNode *s = f->next;

    f->next = s->next;
    s->next = f;
    head = s;

    ListNode *p = f;
    f = f->next;
    while (f != nullptr) {
        s = f->next;
        if (s == nullptr)
            break;
        f->next = s->next;
        s->next = f;
        p->next = s;
        p = f;
        f = f->next;
    }
    return head;
}

// 143. Reorder List
// Given a singly linked list L: L0->L1->...->Ln-1->Ln, reorder it to:
// L0->Ln->L1->Ln-1->L2->Ln-2->... You must do this in-place without altering
// the nodes' values. For example, Given { 1,2,3,4 }, reorder it to { 1,4,2,3 }.
static void reorderList(ListNode *head) {
    if (head == nullptr)
        return;
    // Find the middle node. When the while-loop stops, pointer first
    // is the median node if there are odd number of nodes, or the higher
    // median node if there are even number of nodes.
    ListNode *first = head;
    ListNode *second = head;
    while (second != nullptr && second->next != nullptr) {
        first = first->next;
        second = second->next->next;
    }
    // Break the list into two lists
    ListNode *tail = first;
    ListNode *head2 = tail->next;
    tail->next = nullptr;
    if (head2 == nullptr)
        return;
    // Reverse the second list
    ListNode *prev = nullptr;
    ListNode *middle = head2;
    ListNode *next = middle->next;
    while (next != nullptr) {
        middle->next = prev;
        prev = middle;
        middle = next;
        next = middle->next;
    }
    middle->next = prev;
    // Merge the two lists
    head2 = middle;
    first = head;
    while (head2 != nullptr) {
        second = head2;
        head2 = second->next;
        second->next = first->next;
        first->next = second;
        first = second->next;
    }
}

// Given a linked list, remove the nth node from the end of list and return its
// head. For example, Given linked list: 1->2->3->4->5, and n = 2. After
// removing the second node from the end, the linked list becomes 1->2->3->5.
static ListNode *RemoveNthFromEnd(ListNode *head, int n) {
    if (head == nullptr || n <= 0)
        return head;
    ListNode *q = head;
    int i = 0;
    while (i < n && q->next != nullptr) {
        q = q->next;
        i++;
    }
    if (i < n - 1) // only i + 1 (less than n) nodes in the list
        return head;
    ListNode *p = head;
    if (i == n - 1) {
        // Exact i + 1 (= n) nodes in the list
        head = p->next;
        delete p;
        return head;
    }
    while (q->next != nullptr) {
        p = p->next;
        q = q->next;
    }
    q = p->next;
    p->next = q->next;
    delete q;
    return head;
}

// 83. Remove Duplicates from Sorted List
// Given a sorted linked list, delete all duplicates such that each element
// appear only once. For example, Given 1->1->2, return 1->2.
// Given 1->1->2->3->3, return 1->2->3.
static ListNode *deleteDuplicates(ListNode *head) {
    ListNode *p = head;
    while (p != nullptr) {
        if (p->next != nullptr && p->val == p->next->val) {
            ListNode *n = p->next;
            p->next = n->next;
            delete n;
        } else {
            p = p->next;
        }
    }
    return head;
}

// 82. Remove Duplicates from Sorted List II
// Given a sorted linked list, delete all nodes that have duplicate numbers,
// leaving only distinct numbers from the original list. For example,
// Given 1->2->3->3->4->4->5, return 1->2->5.
// Given 1->1->1->2->3, return 2->3.
static ListNode *deleteDuplicates2(ListNode *head) {
    ListNode *prev = nullptr;
    ListNode *p = head;
    ListNode *next = nullptr;
    while (p != nullptr) {
        if (p->next != nullptr && p->val == p->next->val) {
            int v = p->val;
            while (p != nullptr && p->val == v) {
                next = p->next;
                delete p;
                p = next;
            }
            if (prev == nullptr) {
                head = p;
            } else {
                prev->next = p;
            }
        } else {
            if (prev == nullptr) {
                head = p;
            } else {
                prev->next = p;
            }
            prev = p;
            p = p->next;
        }
    }
    return head;
}
static ListNode *deleteDuplicates2_1(ListNode *head) {
    if (head == nullptr)
        return nullptr;

    ListNode *p;

    while (head->next != nullptr && head->val == head->next->val) {
        int dup = head->val;
        while (head != nullptr && head->val == dup) {
            p = head;
            head = p->next;
            delete p;
        }

        if (head == nullptr)
            return nullptr;
    }

    if (head->next == nullptr)
        return head;

    p = head;
    ListNode *q = p->next;

    while (q->next != nullptr) {
        if (q->val != q->next->val) {
            p = q;
            q = p->next;
        } else {
            int dup = q->val;
            while (q != nullptr && q->val == dup) {
                p->next = q->next;
                delete q;
                q = p->next;
            }
            if (q == nullptr)
                return head;
        }
    }

    return head;
}

// 86. Partition List
// Given a linked list and a value x, partition it such that all nodes less than
// x come before nodes greater than or equal to x. You should preserve the
// original relative order of the nodes in each of the two partitions. For
// example, Given 1->4->3->2->5->2 and x = 3, return 1->2->2->4->3->5.
static ListNode *partition(ListNode *head, int x) {
    if (head == nullptr)
        return head;
    ListNode *prev = nullptr;
    if (head->val < x) {
        prev = head;
    }
    ListNode *p = head;
    while (p->next != nullptr) {
        if (p->next->val < x) {
            if (prev == p) {
                prev = p->next;
                p = p->next;
            } else {
                ListNode *next = p->next;
                p->next = next->next;
                if (prev == nullptr) {
                    next->next = head;
                    head = next;
                    prev = next;
                } else {
                    next->next = prev->next;
                    prev->next = next;
                    prev = next;
                }
            }
        } else {
            p = p->next;
        }
    }
    return head;
}
static ListNode *partition2(ListNode *head, int x) {
    if (head == nullptr)
        return nullptr;

    // p is the last node less than x
    ListNode *p = head;

    // q is the last node no less than x
    ListNode *q = head;

    if (head->val >= x) {
        while (q->next != nullptr && q->next->val >= x)
            q = q->next;
        if (q->next == nullptr) {
            // every node is equal to or greater than x
            return head;
        }

        // q->next is less than x
        ListNode *t = q->next;
        q->next = t->next;
        t->next = head;
        head = t;

        p = head;
    } else {
        while (p->next != nullptr && p->next->val < x)
            p = p->next;
        if (p->next == nullptr) {
            // every node is less than x
            return head;
        }

        q = p->next;
    }

    // Now check if q->next should be moved to be after p

    while (q->next != nullptr) {
        if (q->next->val < x) {
            ListNode *t = q->next;
            q->next = t->next;
            t->next = p->next;
            p->next = t;
            p = t;
        } else {
            q = q->next;
        }
    }

    return head;
}

// 147. Insertion Sort List
// Sort a linked list using insertion sort.
static ListNode *insertionSortList(ListNode *head) {
    if (head == nullptr || head->next == nullptr)
        return head;
    ListNode *p = head;
    while (p->next != nullptr) {
        if (p->val <= p->next->val) {
            p = p->next;
        } else {
            ListNode *q = p->next;
            p->next = q->next;
            q->next = nullptr;
            if (q->val < head->val) {
                q->next = head;
                head = q;
            } else {
                ListNode *s = head;
                while (s != p && s->next != nullptr && s->next->val <= q->val) {
                    s = s->next;
                }
                q->next = s->next;
                s->next = q;
            }
        }
    }
    return head;
}

// 148. Sort List
// Sort a linked list in O(nlogn) time using constant space complexity.
static ListNode *sortList(ListNode *head) {
    if (head == nullptr || head->next == nullptr)
        return head;
    function<ListNode *(ListNode *, ListNode *)> merge =
        [&](ListNode *l1, ListNode *l2) -> ListNode * {
        if (l1 == nullptr)
            return l2;
        if (l2 == nullptr)
            return l1;
        ListNode *h = nullptr;
        if (l1->val <= l2->val) {
            h = l1;
            l1 = l1->next;
        } else {
            h = l2;
            l2 = l2->next;
        }
        ListNode *p = h;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                p->next = l1;
                l1 = l1->next;
            } else {
                p->next = l2;
                l2 = l2->next;
            }
            p = p->next;
        }
        p->next = l1 == nullptr ? l2 : l1;
        return h;
    };
    function<ListNode *(ListNode *)> sort = [&](ListNode *h) -> ListNode * {
        if (h == nullptr || h->next == nullptr)
            return h;
        ListNode *p = h;
        ListNode *q = h->next;
        while (q != nullptr && q->next != nullptr) {
            p = p->next;
            q = q->next->next;
        }
        q = p->next;
        p->next = nullptr;
        p = sort(h);
        q = sort(q);
        p = merge(p, q);
        return p;
    };
    return sort(head);
}

// 141. Linked List Cycle
// Given a linked list, determine if it has a cycle in it.
// Follow up: Can you solve it without using extra space?
static bool hasCycle(ListNode *head) {
    if (head == nullptr)
        return false;
    ListNode *p1 = head;
    ListNode *p2 = head;
    while (p2 != nullptr && p2->next != nullptr) {
        p1 = p1->next;
        p2 = p2->next->next;
        if (p1 == p2)
            return true;
    }
    return false;
}

// 142. Linked List Cycle II
// Given a linked list, return the node where the cycle begins. If there is no
// cycle, return null. Note: Do not modify the linked list.
// Follow up: Can you solve it without using extra space?
static ListNode *detectCycle(ListNode *head) {
    ListNode *p1 = head;
    ListNode *p2 = head;
    while (p2 != nullptr && p2->next != nullptr) {
        p1 = p1->next;
        p2 = p2->next->next;
        if (p1 == p2)
            break;
    }
    if (p2 == nullptr || p2->next == nullptr)
        return nullptr;
    p1 = head;
    while (p1 != p2) {
        p1 = p1->next;
        p2 = p2->next;
    }
    return p1;
}

// 160. Intersection of Two Linked Lists
// Write a program to find the node at which the intersection of two singly
// linked lists begins. For example, the following two linked lists:
// A:        a1 -> a2
//                   \
//                    >
//                     c1 -> c2 -> c3
//                    >
//                   /
// B : b1 -> b2 -> b3
// begin to intersect at node c1. Notes: If the two linked lists have no
// intersection at all, return null. The linked lists must retain their original
// structure after the function returns. You may assume there are no cycles
// anywhere in the entire linked structure. Your code should preferably run in
// O(n) time and use only O(1) memory.
static ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    function<int(ListNode *)> getLength = [&](ListNode *h) -> int {
        int i = 0;
        while (h != nullptr) {
            i++;
            h = h->next;
        }
        return i;
    };
    function<ListNode *(ListNode *, int)> advance = [&](ListNode *h,
                                                        int n) -> ListNode * {
        while (n > 0) {
            h = h->next;
            n--;
        }
        return h;
    };
    int la = getLength(headA);
    int lb = getLength(headB);
    ListNode *pa = headA;
    ListNode *pb = headB;
    if (la > lb)
        pa = advance(pa, la - lb);
    else
        pb = advance(pb, lb - la);
    while (pa != pb) {
        pa = pa->next;
        pb = pb->next;
    }
    return pa;
}
static ListNode *getIntersectionNode2(ListNode *headA, ListNode *headB) {
    ListNode *pa = headA;
    ListNode *pb = headB;
    while (pa != nullptr && pb != nullptr && pa != pb) {
        pa = pa->next;
        pb = pb->next;
        if (pa == pb)
            break;
        if (pa == nullptr)
            pa = headB;
        if (pb == nullptr)
            pb = headA;
    }
    return pa == pb ? pa : nullptr;
}

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

static void Print(TreeNode *node) {
    function<void(stringstream *, int, char)> printChar = [&](stringstream *s,
                                                              int n, char c) {
        if (n > 0) {
            string chars(n, c);
            *s << chars;
        }
    };

    function<void(TreeNode *, unsigned int, int &, int &,
                  vector<stringstream *> &)>
        toString =
            [&](TreeNode *n,    // current node to print
                unsigned int y, // current node level
                int &x, // x-axis position of root of last printed sub tree
                int &r, // x-axis position of right-most boundary of last
                        // printed sub tree
                vector<stringstream *> &ss // output streams, one per level
            ) {
                if (n == nullptr)
                    return;

                if (ss.size() <= y)
                    ss.push_back(new stringstream());

                // print left tree, update x and r accordingly
                toString(n->left, y + 1, x, r, ss);

                stringstream *s = ss[y];

                int l = (int)(s->str().length());
                if (l < x)
                    printChar(s, x - l, ' ');

                if (n->left != nullptr && r > x) {
                    *s << '/';
                    printChar(s, r - x - 1, '-');
                }

                string nc = to_string(n->val);
                *s << nc;

                x = (r + (nc.length() >> 1));
                r = r + nc.length();

                int rx = r;
                int rr = r;
                toString(n->right, y + 1, rx, rr, ss);

                if (n->right != nullptr && rx >= r) {
                    printChar(s, rx - r - 1, '-');
                    *s << '\\';
                }

                // Update the right most boundary
                r = rr;
            };

    vector<stringstream *> streams;
    int x = 0;
    int r = 0;
    toString(node, 0, x, r, streams);

    for_each(streams.begin(), streams.end(), [&](stringstream *s) {
        cout << s->str() << endl;
        delete s;
    });
}

static void DeleteTree(TreeNode *root) {
    if (root == nullptr)
        return;
    if (root->left != nullptr) {
        DeleteTree(root->left);
        root->left = nullptr;
    }
    if (root->right != nullptr) {
        DeleteTree(root->right);
        root->right = nullptr;
    }
    delete root;
}

static TreeNode *Clone(TreeNode *root) {
    if (root == nullptr)
        return nullptr;
    TreeNode *clone = new TreeNode(root->val);
    clone->left = Clone(root->left);
    clone->right = Clone(root->right);
    return clone;
}

// The root-to-leaf path 1->2 represents the number 12.
// The root-to-leaf path 1->3 represents the number 13.
// Return the sum = 12 + 13 = 25.
static int sumNumbers(TreeNode *root) {
    function<void(TreeNode *, int, int &)> sum =
        [&](TreeNode *node, int pathSum, int &totalSum) {
            if (node == nullptr)
                return;
            pathSum = pathSum * 10 + node->val;
            if (node->left == nullptr && node->right == nullptr) {
                totalSum += pathSum;
                return;
            }
            if (node->left != nullptr)
                sum(node->left, pathSum, totalSum);
            if (node->right != nullptr)
                sum(node->right, pathSum, totalSum);
        };
    int total = 0;
    sum(root, 0, total);
    return total;
}

// 112. Path Sum
// Given a binary tree and a sum, determine if the tree has a root-to-leaf path
// such that adding up all the values along the path equals the given sum. For
// example: Given the below binary tree and sum = 22,
//       5
//      / \
//     4   8
//    /   / \
//   11  13  4
//  / \       \
// 7    2      1
// return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
static bool hasPathSum(TreeNode *root, int sum) {
    function<bool(TreeNode *, int)> solve = [&](TreeNode *node,
                                                int parentSum) -> bool {
        if (node == nullptr)
            return false;
        parentSum += node->val;
        if (node->left == nullptr && node->right == nullptr)
            return parentSum == sum;
        return (node->left != nullptr && solve(node->left, parentSum)) ||
               (node->right != nullptr && solve(node->right, parentSum));
    };
    return solve(root, 0);
}

// 113. Path Sum II
// Given a binary tree and a sum, find all root-to-leaf paths where each path's
// sum equals the given sum. For example: Given the below binary tree and sum =
// 22,
//       5
//      / \
//     4   8
//    /   / \
//   11  13  4
//  /  \    / \
// 7    2  5   1
// return
// [
//  [5, 4, 11, 2],
//  [5, 8, 4, 5]
// ]
static vector<vector<int>> pathSum(TreeNode *root, int sum) {
    vector<vector<int>> result;
    function<void(TreeNode *, int, vector<int> &)> solve =
        [&](TreeNode *node, int parentSum, vector<int> &parents) {
            if (node == nullptr)
                return;
            parentSum += node->val;
            parents.push_back(node->val);
            if (node->left == nullptr && node->right == nullptr) {
                if (parentSum == sum) {
                    result.push_back(parents);
                }
            } else {
                if (node->left != nullptr) {
                    vector<int> v(parents);
                    solve(node->left, parentSum, v);
                }
                if (node->right != nullptr) {
                    vector<int> v(parents);
                    solve(node->right, parentSum, v);
                }
            }
        };
    vector<int> c;
    solve(root, 0, c);
    return result;
}

// 144. Binary Tree Preorder Traversal
// Given a binary tree, return the preorder traversal of its nodes' values.
// For example: Given binary tree { 1,#,2,3 },
//  1
//   \
//    2
//   /
//  3
// return [1, 2, 3].
// Note: Recursive solution is trivial, could you do it iteratively?
static vector<int> preorderTraversal(TreeNode *root) {
    vector<int> result;
    if (root == nullptr)
        return result;
    stack<TreeNode *> stack;
    stack.push(root);
    TreeNode *node;
    while (!stack.empty()) {
        node = stack.top();
        stack.pop();
        result.push_back(node->val);
        if (node->right != nullptr)
            stack.push(node->right);
        if (node->left != nullptr)
            stack.push(node->left);
    }
    return result;
}

// 94. Binary Tree Inorder Traversal
// Given a binary tree, return the inorder traversal of its nodes' values.
// For example : Given binary tree[1, null, 2, 3],
//   1
//    \
//     2
//    /
//   3
// return[1, 3, 2].
// Note: Recursive solution is trivial, could you do it iteratively?
static vector<int> inorderTraversal(TreeNode *root) {
    stack<TreeNode *> path;
    TreeNode *node = root;
    vector<int> result;
    while (!path.empty() || node != nullptr) {
        if (node != nullptr) {
            path.push(node);
            node = node->left;
        } else {
            node = path.top();
            path.pop();
            result.push_back(node->val);
            node = node->right;
        }
    }
    return result;
}
static vector<int> inorderTraversal_2(TreeNode *root) {
    if (root == nullptr)
        return vector<int>{};
    stack<TreeNode *> path;
    TreeNode *lastVisited = nullptr;
    path.push(root);
    TreeNode *node;
    vector<int> result;
    while (!path.empty()) {
        node = path.top();
        if (node->right != nullptr && node->right == lastVisited) {
            path.pop();
            lastVisited = node;
        } else if (node->left != nullptr && node->left != lastVisited) {
            path.push(node->left);
            lastVisited = node;
        } else {
            // left is null or left is just visited
            result.push_back(node->val);
            lastVisited = node;
            if (node->right != nullptr) {
                path.push(node->right);
            } else {
                path.pop();
            }
        }
    }
    return result;
}

// 145. Binary Tree Postorder Traversal
// Given a binary tree, return the postorder traversal of its nodes' values.
// For example: Given binary tree { 1,#,2,3 },
//  1
//   \
//    2
//   /
//  3
// return [3, 2, 1].
// Note: Recursive solution is trivial, could you do it iteratively?
static vector<int> postorderTraversal(TreeNode *root) {
    vector<int> result;
    if (root == nullptr)
        return result;
    stack<TreeNode *> stack;
    TreeNode *lastVisited = nullptr;
    TreeNode *node = root;
    while (!stack.empty() || node != nullptr) {
        if (node != nullptr) {
            stack.push(node);
            lastVisited = node;
            node = node->left;
        } else {
            TreeNode *top = stack.top();
            if (top->right != nullptr && lastVisited != top->right) {
                node = top->right;
            } else {
                stack.pop();
                result.push_back(top->val);
                lastVisited = top;
            }
        }
    }
    return result;
}

// 95. Unique Binary Search Trees II
// Given an integer n, generate all structurally unique BST's (binary search
// trees) that store values 1...n. For example, Given n = 3, your program should
// return all 5 unique BST's shown below.
//  1         3     3      2      1
//   \       /     /      / \      \
//    3     2     1      1   3      2
//   /     /       \                 \
//  2     1         2                 3
static vector<TreeNode *> generateTrees(int n) {
    if (n <= 0)
        return vector<TreeNode *>{};
    function<vector<vector<int>>(int, int)> generateSerializations =
        [&](int i, int j) -> vector<vector<int>> {
        vector<vector<int>> serializations;
        if (i > j) {
            serializations.push_back(vector<int>{0});
        } else {
            for (int k = i; k <= j; k++) {
                vector<vector<int>> leftSerializations =
                    generateSerializations(i, k - 1);
                vector<vector<int>> rightSerializations =
                    generateSerializations(k + 1, j);
                for (size_t l = 0; l < leftSerializations.size(); l++) {
                    for (size_t r = 0; r < rightSerializations.size(); r++) {
                        vector<int> serialization = {k};
                        serialization.insert(serialization.end(),
                                             leftSerializations[l].begin(),
                                             leftSerializations[l].end());
                        serialization.insert(serialization.end(),
                                             rightSerializations[r].begin(),
                                             rightSerializations[r].end());
                        serializations.push_back(serialization);
                    }
                }
            }
        }
        return serializations;
    };
    function<TreeNode *(size_t &, vector<int> &)> generateTree =
        [&](size_t &i, vector<int> &serialization) -> TreeNode * {
        if (i >= serialization.size())
            return nullptr;
        if (serialization[i] == 0) {
            i++;
            return nullptr;
        }
        TreeNode *node = new TreeNode(serialization[i++]);
        node->left = generateTree(i, serialization);
        node->right = generateTree(i, serialization);
        return node;
    };
    vector<vector<int>> serializations = generateSerializations(1, n);
    vector<TreeNode *> trees;
    for (size_t i = 0; i < serializations.size(); i++) {
        size_t j = 0;
        trees.push_back(generateTree(j, serializations[i]));
    }
    return trees;
}
// incomplete
static vector<TreeNode *> generateTrees_2(int n) {
    if (n <= 0)
        return vector<TreeNode *>{};
    function<vector<TreeNode *>(int, int)> solve =
        [&](int i, int j) -> vector<TreeNode *> {
        if (i > j) {
            return vector<TreeNode *>{nullptr};
        }
        if (i == j) {
            return vector<TreeNode *>{new TreeNode(i)};
        }
        for (int k = i; k <= j; k++) {
            vector<TreeNode *> leftChildren = solve(i, k - 1);
            vector<TreeNode *> rightChildren = solve(k + 1, j);
        }
        return vector<TreeNode *>{};
    };
    return solve(1, n);
}

// 96. Unique Binary Search Trees
// Given n, how many structurally unique BST's (binary search trees) that store
// values 1...n? For example, Given n = 3, there are a total of 5 unique BST's.
// 1         3     3      2      1
//  \       /     /      / \      \
//   3     2     1      1   3      2
//  /     /       \                 \
// 2     1         2                 3
static int numTrees(int n) {
    if (n <= 0)
        return 0;
    map<pair<int, int>, int> solved;
    function<int(int, int)> count = [&](int i, int j) -> int {
        if (i >= j)
            return 1;
        pair<int, int> p = make_pair(i, j);
        if (solved.find(p) != solved.end())
            return solved[p];
        int c = 0;
        for (int k = i; k <= j; k++) {
            c += (count(i, k - 1) * count(k + 1, j));
        }
        solved[p] = c;
        return c;
    };
    return count(1, n);
}
// c[n] = c[0]*c[n-1] + c[1]*c[n-2] + ... + c[n-2]*c[1] + c[n-1]*c[0]
static int numTrees2(int n) {
    if (n <= 0)
        return 0;
    vector<int> count(n + 1, 0);
    count[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            count[i] += count[j] * count[i - j - 1];
        }
    }
    return count[n];
}

// 98. Validate Binary Search Tree
// Given a binary tree, determine if it is a valid binary search tree (BST).
// Assume a BST is defined as follows: The left subtree of a node contains only
// nodes with keys less than the node's key. The right subtree of a node
// contains only nodes with keys greater than the node's key. Both the left and
// right subtrees must also be binary search trees. Example 1:
//   2
//  / \
// 1   3
// Binary tree [2, 1, 3], return true. Example 2:
//   1
//  / \
// 2   3
// Binary tree [1, 2, 3], return false.
// In-order traverse and check whether values are increasing.
static bool isValidBST(TreeNode *root) {
    stack<TreeNode *> path;
    TreeNode *node = root;
    TreeNode *prev = nullptr;
    while (!path.empty() || node != nullptr) {
        if (node != nullptr) {
            // Move left as much as possible
            path.push(node);
            node = node->left;
        } else {
            // == case 1 ========
            // node is null and is the left child of the top of stack
            //   top
            //   / \
            // null ...
            // == case 2 ========
            // node is null and is the right child of the last visited node
            //     top
            //     /
            //    o
            //   / \
            // null ...
            //       \
            //        o <-- last visited (prev)
            //       / \
            //    null null
            // In both cases, left subtree is done, the top is the one to visit
            node = path.top();
            // Pop the top because no need to visit it again
            path.pop();
            // Visit current node
            if (prev != nullptr && prev->val >= node->val)
                return false;
            prev = node;
            // Move right
            node = node->right;
        }
    }
    return true;
}
static bool isValidBST2(TreeNode *root) {
    if (root == nullptr)
        return true;
    stack<TreeNode *> path;
    path.push(root);
    TreeNode *node = root;
    TreeNode *prev = nullptr;
    TreeNode *lastVisited = nullptr;
    while (!path.empty()) {
        node = path.top();
        if (node->right != nullptr && node->right == lastVisited) {
            lastVisited = node;
            path.pop();
        } else if (node->left != nullptr && node->left != lastVisited) {
            lastVisited = node;
            path.push(node->left);
        } else {
            if (prev != nullptr && prev->val >= node->val)
                return false;
            prev = node;
            lastVisited = node;
            if (node->right != nullptr)
                path.push(node->right);
            else
                path.pop();
        }
    }
    return true;
}
static bool isValidBST3(TreeNode *root) {
    function<bool(TreeNode *, int &, int &)> verify =
        [&](TreeNode *node, int &min, int &max) -> bool {
        if (node == nullptr)
            return true;
        if (node->left == nullptr && node->right == nullptr) {
            min = node->val;
            max = node->val;
            return true;
        }

        if (node->left == nullptr) {
            min = node->val;
        } else {
            int leftMin;
            int leftMax;
            if (!verify(node->left, leftMin, leftMax))
                return false;
            if (leftMax >= node->val)
                return false;
            min = leftMin;
        }

        if (node->right == nullptr) {
            max = node->val;
        } else {
            int rightMin;
            int rightMax;
            if (!verify(node->right, rightMin, rightMax))
                return false;
            if (rightMin <= node->val)
                return false;
            max = rightMax;
        }

        return true;
    };

    int min;
    int max;
    return verify(root, min, max);
}

// 100. Same Tree
// Given two binary trees, write a function to check if they are equal or not.
// Two binary trees are considered equal if they are structurally identical and
// the nodes have the same value.
static bool isSameTree(TreeNode *p, TreeNode *q) {
    function<bool(TreeNode *, TreeNode *)> isSame =
        [&](TreeNode *node1, TreeNode *node2) -> bool {
        if (node1 == nullptr && node2 == nullptr)
            return true;
        if (node1 == nullptr || node2 == nullptr)
            return false;
        if (node1->val != node2->val)
            return false;
        if (!isSame(node1->left, node2->left))
            return false;
        return isSame(node1->right, node2->right);
    };
    return isSame(p, q);
}

// 101. Symmetric Tree
// Given a binary tree, check whether it is a mirror of itself (ie, symmetric
// around its center). For example, this binary tree [1, 2, 2, 3, 4, 4, 3] is
// symmetric :
//     1
//    / \
//   2   2
//  / \ / \
// 3  4 4  3
// But the following[1, 2, 2, null, 3, null, 3] is not:
//   1
//  / \
// 2   2
//  \   \
//   3   3
// Note: Bonus points if you could solve it both recursively and iteratively.
static bool isSymmetric(TreeNode *root) {
    function<bool(TreeNode *, TreeNode *)> isSame =
        [&](TreeNode *node1, TreeNode *node2) -> bool {
        if (node1 == nullptr && node2 == nullptr)
            return true;
        if (node1 == nullptr || node2 == nullptr)
            return false;
        if (node1->val != node2->val)
            return false;
        if (!isSame(node1->left, node2->right))
            return false;
        return isSame(node1->right, node2->left);
    };
    return isSame(root, root);
}
static bool isSymmetric_2(TreeNode *root) {
    deque<TreeNode *> deq;
    deq.push_front(root);
    deq.push_back(root);
    TreeNode *node1;
    TreeNode *node2;
    while (!deq.empty()) {
        node1 = deq.front();
        deq.pop_front();
        node2 = deq.back();
        deq.pop_back();
        if (node1 == nullptr && node2 == nullptr)
            continue;
        if (node1 == nullptr || node2 == nullptr)
            return false;
        if (node1->val != node2->val)
            return false;
        deq.push_front(node1->right);
        deq.push_front(node1->left);
        deq.push_back(node2->left);
        deq.push_back(node2->right);
    }
    return true;
}

// 110. Balanced Binary Tree
// Given a binary tree, determine if it is height-balanced. For this problem,
// a height-balanced binary tree is defined as a binary tree in which the depth
// of the two subtrees of every node never differ by more than 1.
static bool isBalanced(TreeNode *root) {
    function<bool(TreeNode *, int &)> solve = [&](TreeNode *node,
                                                  int &depth) -> bool {
        if (node == nullptr) {
            depth = 0;
            return true;
        }
        int leftDepth;
        if (!solve(node->left, leftDepth))
            return false;
        int rightDepth;
        if (!solve(node->right, rightDepth))
            return false;
        if (abs(leftDepth - rightDepth) > 1)
            return false;
        depth = 1 + max(leftDepth, rightDepth);
        return true;
    };
    int depth;
    return solve(root, depth);
}

// 102. Binary Tree Level Order Traversal
// Given a binary tree, return the level order traversal of its nodes' values.
// (ie, from left to right, level by level). For example :
// Given binary tree [3, 9, 20, null, null, 15, 7],
//   3
//  / \
// 9  20
//    / \
//  15   7
// return its level order traversal as :
// [
//  [3],
//  [9, 20],
//  [15, 7]
// ]
static vector<vector<int>> levelOrder(TreeNode *root) {
    vector<vector<int>> result;
    if (root == nullptr)
        return result;
    queue<TreeNode *> q[2];
    q[0].push(root);
    int level = 0;
    while (!q[0].empty() || !q[1].empty()) {
        int currentLevel = level % 2;
        int nextLevel = (level + 1) % 2;
        vector<int> v;
        TreeNode *node;
        while (!q[currentLevel].empty()) {
            node = q[currentLevel].front();
            q[currentLevel].pop();
            v.push_back(node->val);
            if (node->left != nullptr)
                q[nextLevel].push(node->left);
            if (node->right != nullptr)
                q[nextLevel].push(node->right);
        }
        result.push_back(v);
        level++;
    }
    return result;
}

// 103. Binary Tree Zigzag Level Order Traversal
// Given a binary tree, return the zigzag level order traversal of its nodes'
// values. (ie, from left to right, then right to left for the next level and
// alternate between). For example :
// Given binary tree [3, 9, 20, null, null, 15, 7],
//   3
//  / \
// 9  20
//    / \
//  15   7
// return its zigzag level order traversal as :
// [
//  [3],
//  [20, 9],
//  [15, 7]
// ]
static vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
    vector<vector<int>> result;
    if (root == nullptr)
        return result;
    deque<TreeNode *> q[2];
    int level = 0;
    bool leftToRight = true;
    q[0].push_back(root);
    while (!q[0].empty() || !q[1].empty()) {
        int currentLevel = level % 2;
        int nextLevel = (level + 1) % 2;
        vector<int> v;
        TreeNode *node;
        if (leftToRight) {
            while (!q[currentLevel].empty()) {
                node = q[currentLevel].front();
                q[currentLevel].pop_front();
                v.push_back(node->val);
                if (node->left != nullptr)
                    q[nextLevel].push_back(node->left);
                if (node->right != nullptr)
                    q[nextLevel].push_back(node->right);
            }
        } else {
            while (!q[currentLevel].empty()) {
                node = q[currentLevel].back();
                q[currentLevel].pop_back();
                v.push_back(node->val);
                if (node->right != nullptr)
                    q[nextLevel].push_front(node->right);
                if (node->left != nullptr)
                    q[nextLevel].push_front(node->left);
            }
        }
        result.push_back(v);
        level++;
        leftToRight = !leftToRight;
    }
    return result;
}

// 107. Binary Tree Level Order Traversal II
// Given a binary tree, return the bottom-up level order traversal of its nodes'
// values. (ie, from left to right, level by level from leaf to root). For
// example : Given binary tree [3, 9, 20, null, null, 15, 7],
//   3
//  / \
// 9  20
//    / \
//  15   7
// return its bottom - up level order traversal as :
// [
//   [15, 7],
//   [9, 20],
//   [3]
// ]
static vector<vector<int>> levelOrderBottom(TreeNode *root) {
    vector<vector<int>> result;
    if (root == nullptr)
        return result;
    queue<TreeNode *> q[2];
    q[0].push(root);
    int level = 0;
    TreeNode *node;
    while (!q[0].empty() || !q[1].empty()) {
        int currentLevel = level % 2;
        int nextLevel = (level + 1) % 2;
        vector<int> v;
        while (!q[currentLevel].empty()) {
            node = q[currentLevel].front();
            q[currentLevel].pop();
            v.push_back(node->val);
            if (node->left != nullptr)
                q[nextLevel].push(node->left);
            if (node->right != nullptr)
                q[nextLevel].push(node->right);
        }
        result.insert(result.begin(), v);
        level++;
    }
    return result;
}

// 199. Binary Tree Right Side View
// Given a binary tree, imagine yourself standing on the right side of it,
// return the values of the nodes you can see ordered from top to bottom.
// For example: Given the following binary tree,
//   1      <---
//  / \
// 2   3    <---
//  \   \
//   5   4  <---
// You should return [1, 3, 4].
static vector<int> rightSideView(TreeNode *root) {
    vector<int> result;
    if (root == nullptr)
        return result;
    queue<TreeNode *> q[2];
    q[0].push(root);
    int level = 0;
    int current = 0;
    int next = 0;
    TreeNode *p;
    while (!q[0].empty() || !q[1].empty()) {
        current = level % 2;
        next = (level + 1) % 2;
        p = q[current].front();
        result.push_back(p->val);
        while (!q[current].empty()) {
            p = q[current].front();
            q[current].pop();
            if (p->right != nullptr) {
                q[next].push(p->right);
            }
            if (p->left != nullptr) {
                q[next].push(p->left);
            }
        }
        level++;
    }
    return result;
}

// 104. Maximum Depth of Binary Tree
// Given a binary tree, find its maximum depth. The maximum depth is the number
// of nodes along the longest path from the root node down to the farthest leaf
// node.
static int maxDepth(TreeNode *root) {
    function<int(TreeNode *)> depth = [&](TreeNode *node) -> int {
        if (node == nullptr)
            return 0;
        if (node->left == nullptr && node->right == nullptr)
            return 1;
        return 1 + max(depth(node->left), depth(node->right));
    };
    return depth(root);
}
// This is wrong
static int maxDepth_2(TreeNode *root) {
    if (root == nullptr)
        return 0;
    stack<TreeNode *> path;
    path.push(root);
    TreeNode *node;
    int depth = 1;
    int maxDepth = 0;
    while (!path.empty()) {
        if (depth > maxDepth) {
            maxDepth = depth;
        }
        node = path.top();
        path.pop();
        if (node->right == nullptr && node->left == nullptr) {
            depth--;
        } else {
            depth++;
            if (node->right != nullptr)
                path.push(node->right);
            if (node->left != nullptr)
                path.push(node->left);
        }
    }
    return maxDepth;
}

// 111. Minimum Depth of Binary Tree
// Given a binary tree, find its minimum depth. The minimum depth is the number
// of nodes along the shortest path from the root node down to the nearest leaf
// node.
static int minDepth(TreeNode *root) {
    function<int(TreeNode *, int)> solve = [&](TreeNode *node,
                                               int depth) -> int {
        if (node == nullptr)
            return depth;
        depth++;
        if (node->left == nullptr)
            return solve(node->right, depth);
        else if (node->right == nullptr)
            return solve(node->left, depth);
        else
            return min(solve(node->left, depth), solve(node->right, depth));
    };
    return solve(root, 0);
}

// 105. Construct Binary Tree from Preorder and Inorder Traversal
// Given preorder and inorder traversal of a tree, construct the binary tree.
// Note: You may assume that duplicates do not exist in the tree.
static TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
    function<TreeNode *(int, int, int, int)> build = [&](int i1, int i2, int j1,
                                                         int j2) -> TreeNode * {
        if (i1 > i2)
            return nullptr;
        TreeNode *node = new TreeNode(preorder[i1]);
        int k;
        for (k = j1; k <= j2; k++) {
            if (preorder[i1] == inorder[k])
                break;
        }
        if (k <= j2) {
            node->left = build(i1 + 1, i1 + k - j1, j1, k - 1);
            node->right = build(i1 + k - j1 + 1, i2, k + 1, j2);
        }
        return node;
    };
    return build(0, preorder.size() - 1, 0, inorder.size() - 1);
}

// 106. Construct Binary Tree from Inorder and Postorder Traversal
// Given inorder and postorder traversal of a tree, construct the binary tree.
// Note: You may assume that duplicates do not exist in the tree.
static TreeNode *buildTreeInOrderPostOrder(vector<int> &inorder,
                                           vector<int> &postorder) {
    function<TreeNode *(int, int, int, int)> build = [&](int i1, int i2, int j1,
                                                         int j2) -> TreeNode * {
        if (j1 > j2)
            return nullptr;
        TreeNode *node = new TreeNode(postorder[j2]);
        int k;
        for (k = i1; k <= i2; k++) {
            if (inorder[k] == postorder[j2])
                break;
        }
        if (k <= i2) {
            node->left = build(i1, k - 1, j1, j2 - i2 + k - 1);
            node->right = build(k + 1, i2, j2 - i2 + k, j2 - 1);
        }
        return node;
    };
    return build(0, inorder.size() - 1, 0, postorder.size() - 1);
}

// 108. Convert Sorted Array to Binary Search Tree
// Given an array where elements are sorted in ascending order, convert it to a
// height balanced BST.
static TreeNode *sortedArrayToBST(vector<int> &nums) {
    function<TreeNode *(int, int)> build = [&](int i, int j) -> TreeNode * {
        if (i > j)
            return nullptr;
        int k = i + ((j - i) >> 1);
        TreeNode *node = new TreeNode(nums[k]);
        node->left = build(i, k - 1);
        node->right = build(k + 1, j);
        return node;
    };
    return build(0, nums.size() - 1);
}

// 109. Convert Sorted List to Binary Search Tree
// Given a singly linked list where elements are sorted in ascending order,
// convert it to a height balanced BST.
static TreeNode *sortedListToBST(ListNode *head) {
    if (head == nullptr)
        return nullptr;
    if (head->next == nullptr)
        return new TreeNode(head->val);
    function<TreeNode *(ListNode *, ListNode *)> build =
        [&](ListNode *b, ListNode *e) -> TreeNode * {
        if (b == nullptr || e == nullptr)
            return nullptr;
        TreeNode *node;
        if (b == e) {
            node = new TreeNode(b->val);
        } else if (b->next == e) {
            node = new TreeNode(b->val);
            node->right = new TreeNode(e->val);
        } else {
            ListNode *p = b;
            ListNode *q = p->next->next;
            while (q != e && q->next != e) {
                p = p->next;
                q = q->next;
                q = q->next;
            }
            node = new TreeNode(p->next->val);
            node->left = build(b, p);
            node->right = build(p->next->next, e);
        }
        return node;
    };
    ListNode *p = head;
    ListNode *q = p->next;
    while (q->next != nullptr && q->next->next != nullptr) {
        p = p->next;
        q = q->next;
        q = q->next;
    }
    TreeNode *node = new TreeNode(p->next->val);
    node->left = build(head, p);
    node->right = build(p->next->next, q->next == nullptr ? q : q->next);
    return node;
}

// 114. Flatten Binary Tree to Linked List
// Given a binary tree, flatten it to a linked list in-place. For example, Given
//     1
//    / \
//   2   5
//  / \   \
// 3   4   6
// The flattened tree should look like:
// 1
//  \
//   2
//    \
//     3
//      \
//       4
//        \
//         5
//          \
//           6
static void flatten(TreeNode *root) {
    function<TreeNode *(TreeNode *)> solve = [&](TreeNode *node) -> TreeNode * {
        if (node == nullptr)
            return nullptr;
        if (node->left == nullptr && node->right == nullptr) {
            return node;
        }
        TreeNode *leftTail = solve(node->left);
        TreeNode *rightTail = solve(node->right);
        if (leftTail != nullptr) {
            leftTail->right = node->right;
            node->right = node->left;
            node->left = nullptr;
        }
        return rightTail == nullptr ? leftTail : rightTail;
    };
    solve(root);
}

// 173. Binary Search Tree Iterator
// Implement an iterator over a binary search tree (BST). Your iterator will be
// initialized with the root node of a BST. Calling next() will return the next
// smallest number in the BST. Note: next() and hasNext() should run in average
// O(1) time and uses O(h) memory, where h is the height of the tree.
class BSTIterator {
  private:
    stack<TreeNode *> _stack;
    TreeNode *_node;

  public:
    BSTIterator(TreeNode *root) { _node = root; }

    /** @return whether we have a next smallest number */
    bool hasNext() { return !_stack.empty() || _node != nullptr; }

    /** @return the next smallest number */
    int next() {
        int val;
        while (hasNext()) {
            if (_node != nullptr) {
                _stack.push(_node);
                _node = _node->left;
            } else {
                _node = _stack.top();
                _stack.pop();
                val = _node->val;
                _node = _node->right;
                break;
            }
        }
        return val;
    }
};

struct TreeLinkNode {
    TreeLinkNode *left;
    TreeLinkNode *right;
    TreeLinkNode *next;
};

// 116. Populating Next Right Pointers in Each Node
// Given a binary tree Populate each next pointer to point to its next right
// node. If there is no next right node, the next pointer should be set to NULL.
// Initially, all next pointers are set to NULL. Note: You may only use constant
// extra space. You may assume that it is a perfect binary tree (ie, all leaves
// are at the same level, and every parent has two children). For example, Given
// the following perfect binary tree,
//      1
//    /   \
//   2     3
//  / \   / \
// 4   5 6   7
// After calling your function, the tree should look like :
//      1->NULL
//    /   \
//   2 ->  3->NULL
//  / \   / \
// 4-> 5->6->7->NULL
static void connect(TreeLinkNode *root) {
    TreeLinkNode *leftMost = root;
    while (leftMost != nullptr && leftMost->left != nullptr) {
        TreeLinkNode *node = leftMost;
        leftMost = leftMost->left;
        TreeLinkNode *left = nullptr;
        while (node != nullptr) {
            if (left != nullptr) {
                left->next = node->left;
            }
            node->left->next = node->right;
            left = node->right;
            node = node->next;
        }
    }
}

// 117. Populating Next Right Pointers in Each Node II
// Follow up for problem "Populating Next Right Pointers in Each Node". What if
// the given tree could be any binarytree ? Would your previous solution still
// work? Note: You may only use constant extra space. For example, Given the
// following binary tree,
//     1
//    / \
//   2    3
//  / \    \
// 4   5    7
// After calling your function, the tree should look like :
//     1->NULL
//    / \
//   2 -> 3->NULL
//  / \    \
// 4-> 5 -> 7->NULL
static void connect2(TreeLinkNode *root) {
    TreeLinkNode *leftMost = root;
    while (leftMost != nullptr) {
        TreeLinkNode *node = leftMost;
        leftMost = nullptr;
        TreeLinkNode *left = nullptr;
        while (node != nullptr) {
            if (node->left != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->left;
                }
                if (left != nullptr) {
                    left->next = node->left;
                }
                left = node->left;
            }
            if (node->right != nullptr) {
                if (leftMost == nullptr) {
                    leftMost = node->right;
                }
                if (left != nullptr) {
                    left->next = node->right;
                }
                left = node->right;
            }
            node = node->next;
        }
    }
}

// 133. Clone Graph
// Clone an undirected graph. Each node in the graph contains a label and a list
// of its neighbors. OJ's undirected graph serialization: Nodes are labeled
// uniquely. We use # as a separator for each node, and , as a separator for
// node label and each neighbor of the node. As an example, consider the
// serialized graph { 0,1,2#1,2#2,2 }. The graph has a total of three nodes, and
// therefore contains three parts as separated by #. First node is labeled as 0.
// Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect
// node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2
// (itself), thus forming a self-cycle. Visually, the graph looks like the
// following :
//    1
//   /  \
//  /    \
// 0 -- - 2
//       / \
//       \_/
struct UndirectedGraphNode {
    int label;
    vector<UndirectedGraphNode *> neighbors;
    UndirectedGraphNode(int x) : label(x){};
};
static UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    map<int, UndirectedGraphNode *> cloned;
    function<UndirectedGraphNode *(UndirectedGraphNode *)> clone =
        [&](UndirectedGraphNode *n) -> UndirectedGraphNode * {
        if (n == nullptr)
            return nullptr;
        if (cloned.find(n->label) != cloned.end())
            return cloned[n->label];
        UndirectedGraphNode *copy = new UndirectedGraphNode(n->label);
        cloned[n->label] = copy;
        for (size_t i = 0; i < n->neighbors.size(); i++) {
            int label = n->neighbors[i]->label;
            if (cloned.find(label) == cloned.end()) {
                cloned[label] = clone(n->neighbors[i]);
            }
            copy->neighbors.push_back(cloned[label]);
        }
        return copy;
    };
    return clone(node);
}

struct RandomListNode {
    int label;
    RandomListNode *next, *random;
    RandomListNode(int x) : label(x), next(nullptr), random(nullptr) {}
};
// 138. Copy List with Random Pointer
// A linked list is given such that each node contains an additional random
// pointer which could point to any node in the list or null. Return a deep copy
// of the list.
static RandomListNode *copyRandomList(RandomListNode *head) {
    map<RandomListNode *, RandomListNode *> copied;
    function<RandomListNode *(RandomListNode *)> copy =
        [&](RandomListNode *node) -> RandomListNode * {
        if (node == nullptr)
            return nullptr;
        RandomListNode *c = new RandomListNode(node->label);
        copied[node] = c;
        if (copied.find(node->next) == copied.end()) {
            copied[node->next] = copy(node->next);
        }
        c->next = copied[node->next];
        if (copied.find(node->random) == copied.end()) {
            copied[node->random] = copy(node->random);
        }
        c->random = copied[node->random];
        return c;
    };
    return copy(head);
}
} // namespace LeetCode
} // namespace Test

#endif
